\chapter{Haskell und Hasmtlib}
\label{chapter:haskell}
In diesem Kapitel werden einige notwendige Grundlagen der funktionalen Programmiersprache Haskell erklärt.
Danach wird der Kern der Funktionsweise der Haskell-Bibliothek \texttt{Hasmtlib} \cite{hasmtlib} beschrieben.
Ferner werden einige geeignete Erweiterungen dieser diskutiert.

\section{Funktionale Programmierung mit Haskell}
\label{sec:haskell}
Was ist ein ADT?
Polymorphismus.
Pattern-Matching.
Was ist ein GADT und was kann er besser als ein ADT?
Typ- und Kind-System anreißen - Phasentrennung.
Typklassen.
Typeoperators.
Was ist eine pure Funktion?
Wie kann man Nebenwirkungen dennoch modellieren - was ist eine Monade?
Was ist Lazy?

\section{Hasmtlib - Haskell-Bibliothek für SMTLib}
\label{sec:hasmtlib}
Die Haskell-Bibliothek \texttt{Hasmtlib} \cite{hasmtlib} ist eine eingebettete domänenspezifische Sprache
(englisch \textit{embedded domain-specific language} - kurz \textit{eDSL}) für den SMTLib-Standard Version 2.6 \cite{smtlib} in Haskell.
Eine eDSL ist eine, in einer Gastsprache eingebettete, anwendungsspezifische Sprache, welche auf Grundkonstrukten der Gastsprache aufbaut und somit den
Implementierungsaufwand einer eDSL erheblich reduziert \cite{eDSL}.

Haskell wird aufgrund seines starken Typsystems oft als Gastsprache für solche eingebetteten Sprachen verwendet \cite{eDSL2}.
Listing \ref{listing:hasmtlibexprgadt} zeigt beispielsweise, wie \texttt{Hasmtlib} SMTLib-Ausdrücke als abstrakten Syntaxbaum mit einem GADT repräsentiert.

\begin{listing}[H]
    \inputminted[linenos=true]{haskell}{Code/Implementierung/Hasmtlib/ExprGADT.hs}
    \caption{Repräsentation von SMTLib-Ausdrücken mithilfe eines GADTs in \texttt{Hasmtlib} \cite{hasmtlibExpr}}
    \label{listing:hasmtlibexprgadt}
\end{listing}

Dabei ist der GADT \texttt{Expr t} polymorph in der \texttt{SMTSort}, sodass dessen Kind \texttt{Expr t :: SMTSort -> Type} ist.
Da Werte des Datentyps \texttt{SMTSort} hier als Typen verwendet werden, nennt man \texttt{SMTSort} auch \textit{Data-Kind} oder \textit{Promoted-Type} \cite{singletons}.
Besonders relevant dafür ist das in \ref{sec:haskell} erklärte \textit{Type-Refinement}.
So weist beispielsweise ein Pattern-Match auf den Konstruktor \texttt{Sqrt} bereits zur Übersetzungszeit nach, dass \texttt{t \raisebox{-0.6ex}{\textasciitilde} RealSort} gilt.
Bei anderen Konstruktoren wie \texttt{And} kann die Belegung des \texttt{t} in \texttt{Expr t} mithilfe von Singletons ermittelt werden.
Ein \textit{Singleton} ist ein Laufzeit-Zeuge (Wert) für genau einen Übersetzungszeit-Typen \cite{singletons}.
Diese Abhängigkeit ist aufgrund Haskell's strenger Phasentrennung notwendig und ermöglicht eine \textit{dependent}-ähnliche Kodierung
wie in den Dependently-Typed Programmiersprachen Idris \cite{idris} und Agda \cite{agda}.

Jeder Typ vom Kind \texttt{SMTSort} erhält also einen Singleton (Wert).
Wie in Listing \ref{listing:hasmtlibssmtsort} zu sehen, stellt \texttt{Hasmtlib} den Singleton-Typen \texttt{SSMTSort} ebenfalls als GADT dar.

\begin{listing}[H]
    \inputminted[linenos=true]{haskell}{Code/Implementierung/Hasmtlib/SSMTSort.hs}
    \caption{Repräsentation des Singleton-Typs SSMTSort in \texttt{Hasmtlib} \cite{hasmtlibSSMTSort}}
    \label{listing:hasmtlibssmtsort}
\end{listing}

Die Verbindung zwischen Typ und Wert wird mit der in Listing \ref{listing:hasmtlibknownsmtsort} dargestellten Typklasse \texttt{KnownSMTSort} erreicht.

\begin{listing}[H]
    \inputminted[linenos=true]{haskell}{Code/Implementierung/Hasmtlib/KnownSMTSort.hs}
    \caption{Typklasse zur Verbindung von Typ SMTSort zu Wert SSMTSort in \texttt{Hasmtlib} \cite{hasmtlibSSMTSort}}
    \label{listing:hasmtlibknownsmtsort}
\end{listing}

Mit den genannten Mechanismen garantiert \texttt{Hasmtlib} die ausschließliche Erzeugung von sauber typisierten (englisch \textit{well-typed}) Ausdrücken \cite{gadts}.
Diese werden anschließend von der Bibliothek in SMTLib-Syntax übersetzt und an einen SMT-Solver gegeben.
Dessen Antwort parst und übersetzt \texttt{Hasmtlib} dann zurück in die entsprechenden Haskell-Typen.
Folgend ein kleines Programm zur Erläuterung:

\begin{listing}[H]
    \inputminted[linenos=true]{haskell}{Code/Implementierung/Hasmtlib/BeispielSimple.hs}
    \caption{Beispielhafte Verwendung von Hasmtlib}
    \label{listing:hasmtlibsimplexample}
\end{listing}

Das Beispiel in Listing \ref{listing:hasmtlibsimplexample} demonstriert mit der Funktion \texttt{barLength} außerdem die pure Formelkonstruktion in \texttt{Hasmtlib}.
Lediglich Variablenerzeugung (Zeile 22) und Formel-Assertion (Zeile 24) sind monadisch.
Dadurch lassen sich viele Funktionalitäten der Gastsprache wiederverwenden, zum Beispiel die Funktion \texttt{sum} aus \texttt{Data.Foldable}:
\texttt{sum :: (Foldable t, Num a) => t a -> a}.

\subsection{Ergänzung um Anzahl-Constraints}
\label{subsec:implCardinality}
\texttt{Hasmtlib} unterstützte bis zum Zeitpunkt dieser Arbeit keine Anzahl-Constraints.
Daher werden diese im Rahmen dieser Arbeit der Bibliothek hinzugefügt.
Die Implementierung erfolgt analog zu den in \ref{sec:smtcardinality} präsentierten Kodierungen.
Folgend ein Ausschnitt für das At-Most-Constraint:

\begin{listing}[H]
    \inputminted[linenos=true]{haskell}{Code/Implementierung/Hasmtlib/Cardinality.hs}
    \caption{At-Most-One-Constraint in \texttt{Hasmtlib} \cite{hasmtlibCardinality}}
    \label{listing:hasmtlibcardinality}
\end{listing}

\subsection{Ergänzung um Incremental Refinement}
\label{subsec:incrementalrefinement}
\texttt{Hasmtlib} kann aufbauend auf SMT-Problemen auch OMT-Probleme kodieren.
Da dies allerdings nur wenige SMT-Solver wie \texttt{Z3} direkt unterstützen, verwendet man häufig sogenannte Optimierungsschleifen \cite{nuz3}.
Dabei werden iterativ bessere Lösungen gesucht, indem obere Schranken für Maxima oder untere Schranken für Minima verfeinert werden.
SMT-Solver haben einen Incremental-Stack, welcher die Wiederverwendung von bereits definierten Problemen und auch erlernten Lemmas ermöglicht,
sodass \textit{Incremental Refinement} wesentlich effizienter als das Starten eines neuen Solver-Prozesses für jede Verfeinerung ist \cite{incremental}.

Im Rahmen dieser Arbeit wird \texttt{Hasmtlib} daher um eine solche Optimierungsschleife folgend erweitert:
% TODO: Mittlerweile erweitert, sollte vermutlich lieber in Appendix, weil lang
\begin{listing}[H]
    \inputminted[linenos=true]{haskell}{Code/Implementierung/Hasmtlib/IncrementalRefinement.hs}
    \caption{Incremental Refinement in \texttt{Hasmtlib} \cite{hasmtlibCardinality}}
    \label{listing:incrementalrefinement}
\end{listing}

Wie in Listing \ref{listing:incrementalrefinement} zu erkennen ist, wurde außerdem eine Schrittweite für das Anpassen der verfeinerten Schranken hinzugefügt.
Um nicht über die optimale Lösung zu schreiten, ruft Zeile 27 die Optimierungsschleife nochmals - aber ohne Schrittweite - auf.
Die letzte bekannte optimale Schranke liegt dabei noch auf dem Incremental-Stack, sodass der rekursive Aufruf in Zeile 27 mit dieser als neue Schranke startet.
Das garantiert das Finden der optimalen Lösung.
