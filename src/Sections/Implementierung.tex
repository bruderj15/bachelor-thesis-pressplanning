\chapter{Implementierung in Haskell}
\label{chapter:implementierung}
In diesem Kapitel wird gezeigt, wie SMT-Probleme mit funktionaler Programmierung in SMTLib kodiert werden können.
Dazu werden zunächst einige Grundlagen der funktionalen Programmiersprache Haskell erklärt.
Danach wird der Kern der Funktionsweise der Haskell-Bibliothek \texttt{Hasmtlib} \cite{hasmtlib} untersucht.
Ferner werden einige geeignete Erweiterungen dieser diskutiert.
Anschließend wird mithilfe von Quellcode-Ausschnitten demonstriert, wie das Pressenplanungsproblem polymorph in der SMT-Sorte in Haskell implementiert werden kann.
Zum Schluss wird die Validierung vermeintlicher Lösungen betrachtet.

\section{Funktionale Programmierung mit Haskell}
Was ist ein ADT?
Was ist ein GADT und was kann er besser als ein ADT?
Was ist eine pure Funktion?
Wie kann man Nebenwirkungen dennoch modellieren - was ist eine Monade?
Was ist Lazy?
Speicher-Aspekte: Referentielle Integrität, \ldots

\section{Hasmtlib - Haskell-Bibliothek für SMTLib}
Was ist eine eDSL?
Welche Aufgaben übernimmt Hasmtlib? - Formel bauen, kodieren, Solver kommunizieren, Lösung dekodieren.
Wie werden Formeln dargestellt (Expr-GADT)?
Warum sind dabei Eigenschaften von dependently-typed-PL (Idris nennen) nützlich? - Singletons (SSMTSort) erklären, Eisenberg zitieren.
Codec erklären.

\subsection{Ergänzung um Anzahl-Constraints}

\subsection{Ergänzung um Incremental Refinement}

\subsection{Ergänzung um Observable-Sharing}
Observable Sharing motivieren.
Grundlagen für Implementierung erklären: Paramorphismen (sprengt das den Rahmen?), StableNames, Tseitin.
Ausschnitte der Implementierung zeigen?
Warum der Aufwand?
Bringt das überhaupt was für den Anwendungsfall Pressenplanung?
Wenn nein: Gehört das hier dann überhaupt rein?
Also benchmarken\ldots?
Geht es vielleicht noch besser als (DAG-)Speicher-Sharing?
Vergleich Formeln auf Gleichheit + Umformungen ermöglichen viel mehr Sharing (speicher-unabhängig).
Warum wird das noch nicht gemacht?

\section{Kodierung des Pressenplanungsproblems}
Zwei Modelle erschweren hier möglicherweise Verständnis für den Leser.
Für ein Modell entscheiden: Relationales Modell begründend wegwerfen, auf Laufzeitmessung verweisen.
Ebenso Unterscheidung Incremental Refinement/OMT, OMT wegwerfen, weil Laufzeit.
Geeignete Programmauszüge: Polymorphe Kodierung in Sorte (damit Logik), vereinzelt Datentypen und Constraints analog zu Modellierung.
Minimal IO erklären.

\section{Validierung der Lösung}
Warum validieren?
Wie validieren?
Wenn Modell richtig und auch richtig in SMT kodiert, dann Ergebnis richtig gdw. Solver Spezifikation erfüllt.
Erfüllt Solver die Spezifikation? Ja hoffentlich - das müssen wir denen abkaufen - oder Nachweis bspw. per SMT-Comp?