\chapter{Implementierung in Haskell}
\label{chapter:implementierung}
In diesem Kapitel wird gezeigt, wie SMT-Probleme mit funktionaler Programmierung in SMTLib kodiert werden können.
Dazu werden zunächst einige Grundlagen der funktionalen Programmiersprache Haskell erklärt.
Danach wird der Kern der Funktionsweise der Haskell-Bibliothek \texttt{Hasmtlib} \cite{hasmtlib} untersucht.
Ferner werden einige geeignete Erweiterungen dieser diskutiert.
Anschließend wird mithilfe von Quellcode-Ausschnitten demonstriert, wie das Pressenplanungsproblem polymorph in der SMT-Sorte in Haskell implementiert werden kann.
Zum Schluss wird die Validierung vermeintlicher Lösungen betrachtet.

\section{Funktionale Programmierung mit Haskell}
\label{sec:haskell}
Was ist ein ADT?
Polymorphismus.
Pattern-Matching.
Was ist ein GADT und was kann er besser als ein ADT?
Typ- und Kind-System anreißen - Phasentrennung.
Typklassen.
Typeoperators.
Was ist eine pure Funktion?
Wie kann man Nebenwirkungen dennoch modellieren - was ist eine Monade?
Was ist Lazy?
Speicher-Aspekte: Referentielle Integrität, \ldots

\section{Hasmtlib - Haskell-Bibliothek für SMTLib}
Die Haskell-Bibliothek \texttt{Hasmtlib} \cite{hasmtlib} ist eine eingebettete domänenspezifische Sprache
(englisch \textit{embedded domain-specific language} - kurz \textit{eDSL}) für den SMTLib-Standard Version 2.6 \cite{smtlib} in Haskell.
Eine eDSL ist eine, in einer Gastsprache eingebettete, anwendungsspezifische Sprache, welche auf Grundkonstrukten der Gastsprache aufbaut und somit den
Implementierungsaufwand einer eDSL erheblich reduziert \cite{eDSL}.

Haskell wird aufgrund seines starken Typsystems oft als Gastsprache für solche eingebetteten Sprachen verwendet \cite{eDSL2}.
Listing \ref{listing:hasmtlibexprgadt} zeigt beispielsweise, wie \texttt{Hasmtlib} SMTLib-Ausdrücke als abstrakten Syntaxbaum mit einem GADT repräsentiert.

\begin{listing}[H]
    \inputminted[linenos=true]{haskell}{Code/Implementierung/Hasmtlib/ExprGADT.hs}
    \caption{Repräsentation von SMTLib-Ausdrücken mithilfe eines GADTs in \texttt{Hasmtlib} \cite{hasmtlibExpr}}
    \label{listing:hasmtlibexprgadt}
\end{listing}

Dabei ist der GADT \texttt{Expr t} polymorph in der \texttt{SMTSort}, sodass dessen Kind \texttt{Expr t :: SMTSort -> Type} ist.
Da Werte des Datentyps \texttt{SMTSort} hier als Typen verwendet werden, nennt man \texttt{SMTSort} auch \textit{Data-Kind} oder \textit{Promoted-Type} \cite{singletons}.
Besonders relevant dafür ist das in \ref{sec:haskell} erklärte \textit{Type-Refinement}.
So weist beispielsweise ein Pattern-Match auf den Konstruktor \texttt{Sqrt} bereits zur Übersetzungszeit nach, dass \texttt{t \raisebox{-0.6ex}{\textasciitilde} RealSort} gilt.
Bei anderen Konstruktoren wie \texttt{And} kann die Belegung des \texttt{t} in \texttt{Expr t} mithilfe von Singletons ermittelt werden.
Ein \textit{Singleton} ist ein Laufzeit-Zeuge (Wert) für genau einen Übersetzungszeit-Typen \cite{singletons}.
Diese Abhängigkeit ist aufgrund Haskell's strenger Phasentrennung notwendig und ermöglicht eine \textit{dependent}-ähnliche Kodierung
wie in den Dependently-Typed Programmiersprachen Idris \cite{idris} und Agda \cite{agda}.

Jeder Typ vom Kind \texttt{SMTSort} erhält also einen Singleton (Wert).
Wie in Listing \ref{listing:hasmtlibssmtsort} zu sehen, stellt \texttt{Hasmtlib} den Singleton-Typen \texttt{SSMTSort} ebenfalls als GADT dar.

\begin{listing}[H]
    \inputminted[linenos=true]{haskell}{Code/Implementierung/Hasmtlib/SSMTSort.hs}
    \caption{Repräsentation des Singleton-Typs SSMTSort in \texttt{Hasmtlib} \cite{hasmtlibSSMTSort}}
    \label{listing:hasmtlibssmtsort}
\end{listing}

Die Verbindung zwischen Typ und Wert wird mit der in Listing \ref{listing:hasmtlibknownsmtsort} dargestellten Typklasse \texttt{KnownSMTSort} erreicht.

\begin{listing}[H]
    \inputminted[linenos=true]{haskell}{Code/Implementierung/Hasmtlib/KnownSMTSort.hs}
    \caption{Typklasse zur Verbindung von Typ SMTSort zu Wert SSMTSort in \texttt{Hasmtlib} \cite{hasmtlibSSMTSort}}
    \label{listing:hasmtlibknownsmtsort}
\end{listing}

Mit den genannten Mechanismen garantiert \texttt{Hasmtlib} die ausschließliche Erzeugung von sauber typisierten (englisch \textit{well-typed}) Ausdrücken \cite{gadts}.
Diese werden anschließend von der Bibliothek in SMTLib-Syntax übersetzt und an einen SMT-Solver gegeben.
Dessen Antwort parst und übersetzt \texttt{Hasmtlib} dann zurück in die entsprechenden Haskell-Typen.
Folgend ein kleines Programm zur Erläuterung:

\begin{listing}[H]
    \inputminted[linenos=true]{haskell}{Code/Implementierung/Hasmtlib/BeispielSimple.hs}
    \caption{Beispielhafte Verwendung von Hasmtlib}
    \label{listing:hasmtlibsimplexample}
\end{listing}

Das Beispiel in Listing \ref{listing:hasmtlibsimplexample} demonstriert außerdem die pure Formelkonstruktion in \texttt{Hasmtlib}.
Der Term \texttt{r + r} in Zeile 21 hat den Typ \texttt{Expr IntSort} während das Atom \texttt{l === r + r} den Typ \texttt{Expr BoolSort} hat.
Lediglich Variablenerzeugung und Formel-Assertion sind monadisch.
Dadurch lassen sich viele Funktionalitäten der Gastsprache wiederverwenden, zum Beispiel die Funktion \texttt{sum} aus \texttt{Data.Foldable}:
\texttt{sum :: (Foldable t, Num a) => t a -> a}.

\subsection{Ergänzung um Anzahl-Constraints}
\texttt{Hasmtlib} unterstützte bis zum Zeitpunkt dieser Arbeit keine Anzahl-Constraints.
Daher werden diese im Rahmen dieser Arbeit der Bibliothek hinzugefügt.
Die Implementierung erfolgt analog zur in \ref{sec:smtcardinality} präsentierten ITE-Kodierung:

\begin{listing}[H]
    \inputminted[linenos=true]{haskell}{Code/Implementierung/Hasmtlib/Cardinality.hs}
    \caption{ITE-Kodierung von Anzahl-Constraints in \texttt{Hasmtlib} \cite{hasmtlibCardinality}}
    \label{listing:hasmtlibcardinality}
\end{listing}

\subsection{Ergänzung um Incremental Refinement}

\subsection{Ergänzung um Observable-Sharing}
Observable Sharing motivieren.
Grundlagen für Implementierung erklären: Paramorphismen (sprengt das den Rahmen?), StableNames, Tseitin.
Ausschnitte der Implementierung zeigen?
Warum der Aufwand?
Bringt das überhaupt was für den Anwendungsfall Pressenplanung?
Wenn nein: Gehört das hier dann überhaupt rein?
Also benchmarken\ldots?
Geht es vielleicht noch besser als (DAG-)Speicher-Sharing?
Vergleich Formeln auf Gleichheit + Umformungen ermöglichen viel mehr Sharing (speicher-unabhängig).
Warum wird das noch nicht gemacht?

\section{Kodierung des Pressenplanungsproblems}
Zwei Modelle erschweren hier möglicherweise Verständnis für den Leser.
Für ein Modell entscheiden: Relationales Modell begründend wegwerfen, auf Laufzeitmessung verweisen.
Ebenso Unterscheidung Incremental Refinement/OMT, OMT wegwerfen, weil Laufzeit.
Geeignete Programmauszüge: Polymorphe Kodierung in Sorte (damit Logik), vereinzelt Datentypen und Constraints analog zu Modellierung.
Minimal IO erklären.

\section{Validierung der Lösung}
Warum validieren?
Wie validieren?
Wenn Modell richtig und auch richtig in SMT kodiert, dann Ergebnis richtig gdw. Solver Spezifikation erfüllt.
Erfüllt Solver die Spezifikation? Ja hoffentlich - das müssen wir denen abkaufen - oder Nachweis bspw. per SMT-Comp?