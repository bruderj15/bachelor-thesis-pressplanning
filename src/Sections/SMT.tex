\chapter{Satisfiability Modulo Theories}
\label{chapter:smt}

In diesem Kapitel wird zuerst das Erfüllbarkeitsproblem der Satisfiability Module Theories - kurz SMT - vorgestellt.
Danach wird auf die Kernelemente des Sprachstandards SMTLib Version 2.6 \cite{smtlib} eingegangen.
Dieser ermöglicht die Kodierung von SMT-Problemen für SMT-Solver \cite{smt}.
Ein SMT-Solver - kurz Solver - ist ein Programm, welches für ein kodiertes Problem die Erfüllbarkeit dieses und für den
Fall \textit{erfüllbar} (englisch \textit{satisfiable} - kurz \textit{sat}) ein Modell für jenes bestimmen kann.
Einige bekannte Solver sind zum Beispiel Z3 \cite{z3}, CVC5 \cite{cvc5}, Yices \cite{yices} und OpenSMT \cite{opensmt}.
Diese und viele andere nehmen jährlich an dem internationalen Wettbewerb SMT-COMP \cite{smtcomp} für SMT-Solver teil,
wo sie sich in verschiedenen Disziplinen miteinander messen.
Am Ende dieses Kapitels wird zudem betrachtet, wie SMT-Probleme nach Zielfunktionen optimiert werden können.

\section{Einführung in das Erfüllbarkeitsproblem SMT}
Logiken, Sorten erklären.
Welche Logiken hier relevant?
Wie lösen die Solver die Probleme der Logiken?
Wie performant lösen die Solver diese - Komplexität?
Aktuelle SMT-Comp - beste Solver für relevante Kategorien nennen.

\section{Sprachstandard SMTLib Version 2.6}
Standard Version 2.6: \cite{smtlib}

\section{SMT-Kodierung von Anzahl-Constraints}
\label{sec:smtcardinality}
%Hier folgende Paper: \cite{suelflow} und \cite{kovasznai}
\sem{Hier sollte vorher klar gemacht werden, warum due hier über Anzahl-Constrains schreibst. Sind die für unsere Problem wichtig oder sind sie ein allgemeiner zentraler Bestandteil der SMT-Kodierung?}
Oftmals werden zur Kodierung von SMT-Problemen auch Anzahl-Constraints benötigt.
Auf einer Menge von $n$ gegeben booleschen Variablen $\{b_0, b_1, \ldots, b_{n-1}\}$ soll dabei die Anzahl wahr belegter Variablen nach $k$ restriktiert werden.
Dabei existieren die folgenden drei Restriktionen:
\begin{itemize}
    \item Mindestens $k$: $atLeast(k, \{b_0, b_1, \ldots, b_{n-1}\})$
    \item Genau $k$: $exactly(k, \{b_0, b_1, \ldots, b_{n-1}\})$
    \item Höchstens $k$: $atMost(k, \{b_0, b_1, \ldots, b_{n-1}\})$
\end{itemize}

Anzahl-Constraints sind nicht Teil des SMTLib-Standards Version 2.6 \cite{smtlib}, sodass nur wenige Solver wie Z3 solche Kodierungen direkt unterstützen \cite{z3Cardinality}.
Daher wird zur manuellen Kodierung \sem{\sout{of}} die ITE-Kodierung verwendet \cite{kovasznai}.
Dabei werden die einzelnen booleschen Unbekannten mithilfe eines If-Then-Else-Ausdrucks (kurz ITE) in numerische Ausdrücke umgewandelt, anschließend summiert und verglichen.
Mithilfe der Hilfsfunktion $count(\{b_0, b_1, \ldots, b_{n-1}\})$ lassen sich die Anzahl-Constraints einfach kodieren:

\[
    \begin{aligned}
        & count(B) = \sum_{\substack{b \in B}}
            \left(
                \begin{cases}
                    1 & \text{, } b \\
                    0 & \text{, sonst}
                \end{cases}
            \right) \\[5pt]
        & atLeast(k, B) = k \leq count(B) \\[5pt]
        & exactly(k, B) = k = count(B) \\[5pt]
        & atMost(k, B) = k \geq count(B)
    \end{aligned}
\]

Je nach gewählter Logik erfolgt die Summierung in der entsprechenden Sorte.
Ist für das SMT-Problem beispielsweise die Logik QF\_LRA gewählt, dann summiert $count(B)$ Terme der Sorte \texttt{Real}.
Dabei entstehen für jedes Anzahl-Constraint offensichtlich $n$ ITE-Ausdrücke, $n-1$ binäre Additionen und ein Vergleich.

\section{Optimierung - Optimization Modulo Theories}
nuZ3 Paper hier sehr hilfreich \cite{nuz3}